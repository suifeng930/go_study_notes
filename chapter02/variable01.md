## Go语言学习笔记02章

[TOC]

### 2.1 变量

------

**变量：**是一段或多段用来存储数据的内存。作为**静态类型语言**，Go**变量**总是有固定的数据类型，类型决定了**变量内存的长度**和**存储格式**。我们只能修改变量值，但无法改变类型。通过类型转换或指针操作，我们可用不同方式修改变量值，但这并不意味着改变了变量类型。

因为内存分配发生在运行期，所以在编码阶段我们用一个易于阅读的名字来表示这段内存。实际上，编译后的机器码从不使用变量名，而是直接通过内存地址来访问目标数据。保存在符号表中的变量名等信息可被删除，或用于输出更详细的错误信息。

------

#### 定义

------

关键词`var`用于定义变量，类型被放在变量名后面。另外，运行时内存分配操作会确保变量自动初始化为二进制零值（zero value）,避免出现不可预测行为。如显示提供初始化值，可省略变量类型,由编译器推断。

```go
var x int                        // 自动初始化为0
var y = false                    // 自动推断为 bool 类型
```

可一次定义多个变量，包括用不同初始值定义不同类型。

```go
var x,y int.                     // 相同类型的多个变量
var a,s=100,"abc"                // 不同类型初始化值，    a --->int.    s ---> string
```

依照惯例，建议以组方式整理多行变量定义。

```go
var (
    x,y int                   // 相同类型的多个变量
    a,s =100,"string"        // 不同类型初始化值，    a --->int.    s ---> string
)
```

#### 简短模式

------

除了`var`关键字外，还可以使用更加简短的变量定义和初始化语法。

```go
func main() {
			X :=100
			a,s :=100, "str"
}
```

**注意：**简短模式`short variable declaration`有些限制

* 定义变量，必须同时初始化。
* 不能提供数据类型。
* 只能用在函数内部。

**错误案例：**比如原本打算修改全局变量，结果变成重新定义同名局部变量。

```go
package main

var x=100                          // 全局变量

func main() {
  println(&x,x)                    //全局变量 x
  
  x :="adc"                        // 重新定义和初始化同名局部变量 x
  
  println(&x,x)
}
//输出： 比较两次输出地址，可以看出是两个不同的变量。
//  0x10ca188 100
//  0xc00003a768 abc

```

<u>简短定义在函数多返回值，以及`if/for/switch`等语句中定义局部变量非常方便。</u>

简短模式并不总是重新定义变量，也可能是部分退化的赋值操作。

```go
package main

//简短模式并不总是重新定义变量，也可能是部分退化的赋值操作。

func main() {

	x := 100

	println(&x)

	x, y := 200, "abc" //注意： x 退化为赋值操作， 仅有y是变量定义

	println(&x, x)
	println(&y, y)
}

// 输出： 
// 0xc00003a760
// 0xc00003a760 200  对比内存地址，可以确认x 属于同一变量
// 0xc00003a768 abc

```

**注意：**退化赋值的前提条件：最少有一个新变量被定义，且必须是同一作用域

```go
package main

//简短模式并不总是重新定义变量，也可能是部分退化的赋值操作。
//退化赋值的前提条件：最少有一个新变量被定义，且必须是同一作用域

func main() {

	z :=100
	println(&z)

	z :=200           //: no new variables on left side of :=

	println(&z,z)
}

```

```go
package main

// 1.简短模式并不总是重新定义变量，也可能是部分退化的赋值操作。
// 2.退化赋值的前提条件：最少有一个新变量被定义，且必须是同一作用域

func main() {

   a :=100
   println(&a,a)
   {
      a,b :=200,"sa"  // 不同作用域，全部是新的局部变量定义
      println(&a,a,b)
   }

}
//输出
// 0xc00003a760 100
// 0xc00003a758 200 sa


```

**退化赋值使用场景：**在处理函数错误返回值时，退化赋值允许我们重复使用`err`变量，这个是相当用的。

#### 多变量赋值

------

在进行多变量赋值操作时，首先计算出所有右值，然后在依此完成赋值操作。

```go
package main

// 多变量赋值

func main() {

	x, y := 1, 2
	x, y = y+3, x+2 // 先计算出右值 y+3，x+2  ,然后再对x,y 变量赋值

	println(x, y)

}
```


![image-20210116224343962](/go_study_notes/chapter02/image-20210116224343962.png)