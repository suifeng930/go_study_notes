## Go语言学习笔记02章

[TOC]

### 2.1 变量

------

**变量：**是一段或多段用来存储数据的内存。作为**静态类型语言**，Go**变量**总是有固定的数据类型，类型决定了**变量内存的长度**和**存储格式**。我们只能修改变量值，但无法改变类型。通过类型转换或指针操作，我们可用不同方式修改变量值，但这并不意味着改变了变量类型。

因为内存分配发生在运行期，所以在编码阶段我们用一个易于阅读的名字来表示这段内存。实际上，编译后的机器码从不使用变量名，而是直接通过内存地址来访问目标数据。保存在符号表中的变量名等信息可被删除，或用于输出更详细的错误信息。

------

#### 定义

------

关键词`var`用于定义变量，类型被放在变量名后面。另外，运行时内存分配操作会确保变量自动初始化为二进制零值（zero value）,避免出现不可预测行为。如显示提供初始化值，可省略变量类型,由编译器推断。

```go
var x int                        // 自动初始化为0
var y = false                    // 自动推断为 bool 类型
```

可一次定义多个变量，包括用不同初始值定义不同类型。

```go
var x,y int.                     // 相同类型的多个变量
var a,s=100,"abc"                // 不同类型初始化值，    a --->int.    s ---> string
```

依照惯例，建议以组方式整理多行变量定义。

```go
var (
    x,y int                   // 相同类型的多个变量
    a,s =100,"string"        // 不同类型初始化值，    a --->int.    s ---> string
)
```

#### 简短模式

------

除了`var`关键字外，还可以使用更加简短的变量定义和初始化语法。

```go
func main() {
			X :=100
			a,s :=100, "str"
}
```

**注意：**简短模式`short variable declaration`有些限制

* 定义变量，必须同时初始化。
* 不能提供数据类型。
* 只能用在函数内部。

**错误案例：**比如原本打算修改全局变量，结果变成重新定义同名局部变量。

```go
package main

var x=100                          // 全局变量

func main() {
  println(&x,x)                    //全局变量 x
  
  x :="adc"                        // 重新定义和初始化同名局部变量 x
  
  println(&x,x)
}
//输出： 比较两次输出地址，可以看出是两个不同的变量。
//  0x10ca188 100
//  0xc00003a768 abc

```

<u>简短定义在函数多返回值，以及`if/for/switch`等语句中定义局部变量非常方便。</u>

简短模式并不总是重新定义变量，也可能是部分退化的赋值操作。

```go
package main

//简短模式并不总是重新定义变量，也可能是部分退化的赋值操作。

func main() {

	x := 100

	println(&x)

	x, y := 200, "abc" //注意： x 退化为赋值操作， 仅有y是变量定义

	println(&x, x)
	println(&y, y)
}

// 输出： 
// 0xc00003a760
// 0xc00003a760 200  对比内存地址，可以确认x 属于同一变量
// 0xc00003a768 abc

```

**注意：**退化赋值的前提条件：最少有一个新变量被定义，且必须是同一作用域

```go
package main

//简短模式并不总是重新定义变量，也可能是部分退化的赋值操作。
//退化赋值的前提条件：最少有一个新变量被定义，且必须是同一作用域

func main() {

	z :=100
	println(&z)

	z :=200           //: no new variables on left side of :=

	println(&z,z)
}

```

```go
package main

// 1.简短模式并不总是重新定义变量，也可能是部分退化的赋值操作。
// 2.退化赋值的前提条件：最少有一个新变量被定义，且必须是同一作用域

func main() {

   a :=100
   println(&a,a)
   {
      a,b :=200,"sa"  // 不同作用域，全部是新的局部变量定义
      println(&a,a,b)
   }

}
//输出
// 0xc00003a760 100
// 0xc00003a758 200 sa


```

**退化赋值使用场景：**在处理函数错误返回值时，退化赋值允许我们重复使用`err`变量，这个是相当用的。

#### 多变量赋值

------

在进行多变量赋值操作时，首先计算出所有右值，然后在依此完成赋值操作。

```go
package main

// 多变量赋值

func main() {

	x, y := 1, 2
	x, y = y+3, x+2 // 先计算出右值 y+3，x+2  ,然后再对x,y 变量赋值

	println(x, y)

}
```


![image-20210116224343962](https://github.com/suifeng930/go_study_notes/blob/main/chapter02/image-20210116224343962.png)

------

### 2.2 命名

------

对变量、常量、函数、自定义类型进行命名，通常优先选用有**实际含义**，**易于阅读和理解**的字母或单词组合。

------

**命名建议：**

* 以字母或下画线开始，由多个字母、数字和下画线组合而成。
* 区分大小写
* 使用驼峰（camel case） 拼写格式
* 局部变量优先使用短名
* 不要使用保留关键字
* 不建议使用与预定义常量、类型、内置函数相同的名字
* 专有名词通常会全部大写，例如`escapeHTML`

```go
package main

func main(){
  var c int                         //c 代替 count
  for i:=0;i<10;i++{                //i 代替 index
    	c++
  }
  println(c)
}
```

符号名字首字母大写决定了其作用域。**首字母大写**的为导出成员，**可被包外引用**，而**小写**则**仅能在包内使用**。

#### 空标识符

------

“_”通常作为忽略占位符使用，可以作为表达式左值，无法读取内容。

------

```go
package main
import( "strconv")

func main() {
  x,_ :=strconv.Atoi("12")              //忽略Atoi 的 err 返回值
  println(x)
}
//空标识符可用来临时规避编译器对未使用变量和导入包的错误检查。但请注意，它是预置成员，不能重新定义。
```

### 2.3 常量

------

常量：表示运行时恒定不可改变的值，通常是一些字面量。使用常量就可用一个易于阅读理解的标识符号来代替“魔法数字”，也使得在调整常量值时，无须修改所有引用代码。**常量值**必须是**编译期可确定**的**字符**、**字符串**、**数字或布尔值**。可指定常量类型，或由编译器通过初始化值推断其类型。

```go
const x,y  int=123,0x22
const s ="hello ,world"
const c ='我'           //rune   (unicode code point)
const(
	i,f =1,0.12           //  int， float64（默认）
  b		= false
)
```

可在函数代码块中定义常量，不曾使用的常量不会引发编译错误。

```go
package main

func main(){
  const x=123
  println(x)
  
  const y =1.23               // 未使用，不会引发编译错误
  {
    const x="anc"            //  在不同作用域定义同名常量
    println(x)
  }
}
// 输出
// 123
// anc
```

如果显示指定类型，必须确保常量左右值类型一致，需要时可做显示转换。右值不能超出常量类型取值范围，否则会引发溢出错误。

```go
const(
	x,y  int =99,-999
	b byte =byte(x)                 // x 被指定为int 类型，须显示转换为byte类型
	n      =uint8(y)                // 错误： constant -999  overflows uint8
)
```

常量值也可以是某些编译器能计算出结果的表达式，如unsafe.Sizeof``、`len`、`cap`等

```go
package main

import ( "unsafe")
const(
  ptrSize =unsafe.Sizeof(uintptr(0))
  strSize =len("hello, world")
)
```

在常量组中如不指定类型和初始化值，则与上一行非空常量右值（表达式文本）相同。

```go
package main

import ( "fmt")

func main() {
  const (
  	x uint16 =120
    y                            //与上一行x类型相同，右值相同
    s ="abc"
    z                           // 与s类型、右值相同
  )
  fmt.Printf("%T,%v \n",y,y)   //输出类型和值
  fmt.Printf("%T,%v \n",z,z)
}
// 输出
// uint16 ,120
// string ,abc
```

#### 枚举

------

Go并没有明确意义上的`enum`定义，不过可以借助`iota`标识符实现一组自增常量值来实现枚举类型。

```go
const(
	x =iota  // 0
	y        // 1
	z        // 2
)
const(
	_  =iota   //0
  KB =1<<(10*iota)   // 1<<(10*1)
  MB                 // 1<<(10*2)
  GB                 // 1<<(10*3)
)
```

自增作用范围为常量组。可在多常量定义中使用多个`iota`，它们各自单独计数，只须确保组中每行常量的列数量相同即可。

```go
const(
	_,_ =iota,iota*10
	a,b                // 1,1*10
	c,d                // 2,2*10
)
```

如中断`iota`自增，则必须显示恢复。且后续自增值按行序递增。

```go
const(
	a    =iota       // 0
  b                // 1
  c    =100        // 100
  d                // 100(与上一行常量右值表达式相同)
  e    =iota       // 4（恢复iota自增，计数包括c,d）
  f                //5
)
```

在实际编码中，建议用自定义类型实现用途明确的枚举类型。但这并不能将取值范围限定在预定义的枚举值内。

```go
 type color byte               // 自定义类型
 
 const(
 	 black color =iota           //指定常量类型	
   red
   blue
 )
func test(c color) {
  println(c)
}
func main(){
  test(red)
  test(100)                     // 100 并未超出color   byte类型取值范围
  
  x :=2
  test(x)                      // 错误： cannot use x (type int) as type color in argument to test
}
```

常量除“只读”外，和变量究竟有什么不同？

```go
var     x=0x100
const   y=0x200

func main(){
  println(&x,x)
  println(&y,y)                    //错误：  cannot take the address  of y
}
```

不同于变量在运行期分配存储内存（非优化状态），**常量**通常**会被编译器**在**预处理阶段直接展开**，**作为指令数据使用**。

数字常量不会分配存储空间，无须像变量那样通过内存寻址来取值，因此无法获取地址。


